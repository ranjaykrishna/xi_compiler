
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sun Oct 16 15:32:40 EDT 2011
//----------------------------------------------------

package rak248.edu.cornell.cs.cs4120.xi.parser;

import java_cup.runtime.*;
import rak248.edu.cornell.cs.cs4120.xi.lexer.*;
import rak248.edu.cornell.cs.cs4120.xi.SyntaxNode;
import rak248.edu.cornell.cs.cs4120.xi.typeChecker.Type;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.LinkedHashMap;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sun Oct 16 15:32:40 EDT 2011
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\207\000\002\002\004\000\002\002\003\000\002\003" +
    "\004\000\002\004\006\000\002\004\002\000\002\005\004" +
    "\000\002\005\004\000\002\005\003\000\002\005\003\000" +
    "\002\006\011\000\002\006\010\000\002\007\007\000\002" +
    "\007\010\000\002\051\005\000\002\010\005\000\002\010" +
    "\007\000\002\010\002\000\002\011\004\000\002\011\005" +
    "\000\002\056\003\000\002\056\004\000\002\057\004\000" +
    "\002\057\005\000\002\012\003\000\002\012\003\000\002" +
    "\013\003\000\002\013\003\000\002\014\004\000\002\015" +
    "\004\000\002\015\003\000\002\015\003\000\002\017\004" +
    "\000\002\017\005\000\002\016\006\000\002\016\005\000" +
    "\002\020\004\000\002\020\002\000\002\021\004\000\002" +
    "\021\004\000\002\021\004\000\002\021\003\000\002\021" +
    "\003\000\002\021\005\000\002\021\007\000\002\022\005" +
    "\000\002\023\005\000\002\024\004\000\002\026\004\000" +
    "\002\025\005\000\002\025\003\000\002\025\003\000\002" +
    "\025\007\000\002\025\005\000\002\025\005\000\002\025" +
    "\003\000\002\025\005\000\002\027\003\000\002\027\003" +
    "\000\002\050\005\000\002\047\007\000\002\030\007\000" +
    "\002\030\006\000\002\030\005\000\002\030\004\000\002" +
    "\030\004\000\002\030\004\000\002\030\004\000\002\030" +
    "\003\000\002\030\003\000\002\046\007\000\002\046\006" +
    "\000\002\046\005\000\002\046\004\000\002\046\004\000" +
    "\002\046\004\000\002\046\004\000\002\046\003\000\002" +
    "\046\003\000\002\031\003\000\002\031\003\000\002\031" +
    "\003\000\002\031\003\000\002\031\003\000\002\031\003" +
    "\000\002\031\003\000\002\031\003\000\002\032\005\000" +
    "\002\033\007\000\002\033\006\000\002\033\005\000\002" +
    "\033\004\000\002\033\004\000\002\033\004\000\002\033" +
    "\003\000\002\033\003\000\002\033\004\000\002\034\003" +
    "\000\002\034\003\000\002\034\003\000\002\034\003\000" +
    "\002\035\003\000\002\035\003\000\002\037\003\000\002" +
    "\037\005\000\002\037\002\000\002\036\006\000\002\053" +
    "\003\000\002\053\004\000\002\054\003\000\002\054\004" +
    "\000\002\055\003\000\002\055\003\000\002\040\004\000" +
    "\002\040\003\000\002\040\005\000\002\040\005\000\002" +
    "\040\005\000\002\040\006\000\002\052\005\000\002\043" +
    "\003\000\002\043\003\000\002\043\003\000\002\043\003" +
    "\000\002\060\006\000\002\041\003\000\002\041\003\000" +
    "\002\041\003\000\002\041\003\000\002\041\003\000\002" +
    "\042\003\000\002\042\002\000\002\044\004\000\002\044" +
    "\004\000\002\045\006\000\002\045\005" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\346\000\006\046\ufffd\053\ufffd\001\002\000\004\002" +
    "\350\001\002\000\006\046\013\053\011\001\002\000\004" +
    "\002\000\001\002\000\006\002\ufffa\053\ufffa\001\002\000" +
    "\006\002\ufff9\053\ufff9\001\002\000\004\036\022\001\002" +
    "\000\006\002\uffff\053\011\001\002\000\004\053\014\001" +
    "\002\000\010\042\015\046\uff7f\053\uff7f\001\002\000\026" +
    "\006\uff80\007\uff80\015\uff80\023\uff80\034\uff80\041\uff80\045" +
    "\uff80\046\uff80\047\uff80\053\uff80\001\002\000\006\046\ufffe" +
    "\053\ufffe\001\002\000\006\002\ufffc\053\ufffc\001\002\000" +
    "\006\002\ufffb\053\ufffb\001\002\000\006\012\044\034\046" +
    "\001\002\000\010\011\ufff1\013\ufff1\053\023\001\002\000" +
    "\004\012\042\001\002\000\006\011\026\013\025\001\002" +
    "\000\004\053\027\001\002\000\006\012\ufff4\034\ufff4\001" +
    "\002\000\004\012\030\001\002\000\006\005\032\024\034" +
    "\001\002\000\006\011\ufff2\013\ufff2\001\002\000\036\006" +
    "\uffe7\007\uffe7\011\uffe7\013\uffe7\015\uffe7\021\uffe7\023\uffe7" +
    "\034\uffe7\035\uffe7\041\uffe7\042\uffe7\045\uffe7\047\uffe7\053" +
    "\uffe7\001\002\000\012\011\uffee\013\uffee\034\uffee\035\036" +
    "\001\002\000\036\006\uffe8\007\uffe8\011\uffe8\013\uffe8\015" +
    "\uffe8\021\uffe8\023\uffe8\034\uffe8\035\uffe8\041\uffe8\042\uffe8" +
    "\045\uffe8\047\uffe8\053\uffe8\001\002\000\012\011\uffed\013" +
    "\uffed\034\uffed\035\040\001\002\000\004\010\037\001\002" +
    "\000\012\011\uffec\013\uffec\034\uffec\035\uffec\001\002\000" +
    "\004\010\041\001\002\000\012\011\uffeb\013\uffeb\034\uffeb" +
    "\035\uffeb\001\002\000\006\005\032\024\034\001\002\000" +
    "\006\011\ufff3\013\ufff3\001\002\000\006\005\032\024\034" +
    "\001\002\000\006\013\340\034\341\001\002\000\020\007" +
    "\uffdd\023\uffdd\034\uffdd\041\uffdd\045\uffdd\047\uffdd\053\uffdd" +
    "\001\002\000\020\007\072\023\061\034\052\041\056\045" +
    "\051\047\054\053\057\001\002\000\026\017\124\025\123" +
    "\030\125\032\112\036\111\044\115\050\127\051\122\052" +
    "\116\053\113\001\002\000\006\013\uffd0\021\uffd0\001\002" +
    "\000\020\007\uffdd\023\uffdd\034\uffdd\041\332\045\uffdd\047" +
    "\uffdd\053\uffdd\001\002\000\022\006\uffde\007\uffde\023\uffde" +
    "\034\uffde\041\uffde\045\uffde\047\uffde\053\uffde\001\002\000" +
    "\004\036\220\001\002\000\022\006\uffd8\007\uffd8\023\uffd8" +
    "\034\uffd8\041\uffd8\045\uffd8\047\uffd8\053\uffd8\001\002\000" +
    "\034\007\uff99\013\uff99\017\124\025\123\030\125\032\112" +
    "\036\111\042\uff99\044\115\050\127\051\122\052\116\053" +
    "\113\001\002\000\014\012\277\013\uffcf\021\uffcf\035\104" +
    "\036\276\001\002\000\004\035\104\001\002\000\004\036" +
    "\220\001\002\000\022\006\uffc9\007\uffc9\023\uffc9\034\uffc9" +
    "\041\uffc9\045\uffc9\047\uffc9\053\uffc9\001\002\000\024\006" +
    "\uff7f\007\uff7f\023\uff7f\034\uff7f\041\uff7f\042\015\045\uff7f" +
    "\047\uff7f\053\uff7f\001\002\000\006\013\077\021\100\001" +
    "\002\000\006\013\uffcb\021\uffcb\001\002\000\022\006\uffd9" +
    "\007\uffd9\023\uffd9\034\uffd9\041\uffd9\045\uffd9\047\uffd9\053" +
    "\uffd9\001\002\000\024\006\uff7f\007\uff7f\023\uff7f\034\uff7f" +
    "\041\uff7f\042\015\045\uff7f\047\uff7f\053\uff7f\001\002\000" +
    "\022\006\uffc8\007\uffc8\023\uffc8\034\uffc8\041\uffc8\045\uffc8" +
    "\047\uffc8\053\uffc8\001\002\000\024\006\uff7f\007\uff7f\023" +
    "\uff7f\034\uff7f\041\uff7f\042\015\045\uff7f\047\uff7f\053\uff7f" +
    "\001\002\000\006\002\ufff6\053\ufff6\001\002\000\004\007" +
    "\074\001\002\000\006\002\ufff5\053\ufff5\001\002\000\022" +
    "\006\uffdc\007\uffdc\023\uffdc\034\uffdc\041\uffdc\045\uffdc\047" +
    "\uffdc\053\uffdc\001\002\000\022\006\uffda\007\uffda\023\uffda" +
    "\034\uffda\041\uffda\045\uffda\047\uffda\053\uffda\001\002\000" +
    "\006\045\102\053\103\001\002\000\026\017\uffd2\025\uffd2" +
    "\030\uffd2\032\uffd2\036\uffd2\044\uffd2\050\uffd2\051\uffd2\052" +
    "\uffd2\053\uffd2\001\002\000\006\013\uffca\021\uffca\001\002" +
    "\000\006\013\uffcd\021\uffcd\001\002\000\014\012\106\013" +
    "\uffcc\021\uffcc\035\104\036\105\001\002\000\026\017\124" +
    "\025\123\030\125\032\112\036\111\044\115\050\127\051" +
    "\122\052\116\053\113\001\002\000\032\011\uff99\013\uff99" +
    "\017\124\025\123\030\125\032\112\036\111\044\115\050" +
    "\127\051\122\052\116\053\113\001\002\000\006\005\032" +
    "\024\034\001\002\000\072\004\uff7e\006\uff7e\007\uff7e\010" +
    "\uff7e\011\uff7e\013\uff7e\014\uff7e\015\uff7e\016\uff7e\020\uff7e" +
    "\021\uff7e\022\uff7e\023\uff7e\026\uff7e\027\uff7e\030\uff7e\031" +
    "\uff7e\033\uff7e\034\uff7e\035\110\037\uff7e\040\uff7e\041\uff7e" +
    "\042\uff7e\043\uff7e\045\uff7e\047\uff7e\053\uff7e\001\002\000" +
    "\026\017\124\025\123\030\125\032\112\036\111\044\115" +
    "\050\127\051\122\052\116\053\113\001\002\000\032\011" +
    "\uff99\013\uff99\017\124\025\123\030\125\032\112\036\111" +
    "\044\115\050\127\051\122\052\116\053\113\001\002\000" +
    "\026\017\uff97\025\uff97\030\uff97\032\uff97\036\uff97\044\uff97" +
    "\050\uff97\051\uff97\052\uff97\053\uff97\001\002\000\072\004" +
    "\uff89\006\uff89\007\uff89\010\uff89\011\uff89\013\uff89\014\uff89" +
    "\015\uff89\016\uff89\020\uff89\022\uff89\023\uff89\026\uff89\027" +
    "\uff89\030\uff89\031\uff89\033\uff89\034\uff89\035\104\036\105" +
    "\037\uff89\040\uff89\041\uff89\042\uff89\043\uff89\045\uff89\047" +
    "\uff89\053\uff89\001\002\000\070\004\uff87\006\uff87\007\uff87" +
    "\010\uff87\011\uff87\013\uff87\014\uff87\015\uff87\016\uff87\020" +
    "\uff87\022\uff87\023\uff87\026\uff87\027\uff87\030\uff87\031\uff87" +
    "\033\uff87\034\uff87\035\104\037\uff87\040\uff87\041\uff87\042" +
    "\uff87\043\uff87\045\uff87\047\uff87\053\uff87\001\002\000\066" +
    "\004\uff9d\006\uff9d\007\uff9d\010\uff9d\011\uff9d\013\uff9d\014" +
    "\uff9d\015\uff9d\016\uff9d\020\uff9d\022\uff9d\023\uff9d\026\uff9d" +
    "\027\uff9d\030\uff9d\031\uff9d\033\uff9d\034\uff9d\037\uff9d\040" +
    "\uff9d\041\uff9d\042\uff9d\043\uff9d\045\uff9d\047\uff9d\053\uff9d" +
    "\001\002\000\066\004\uff9f\006\uff9f\007\uff9f\010\uff9f\011" +
    "\uff9f\013\uff9f\014\uff9f\015\uff9f\016\uff9f\020\uff9f\022\uff9f" +
    "\023\uff9f\026\uff9f\027\uff9f\030\uff9f\031\uff9f\033\uff9f\034" +
    "\uff9f\037\uff9f\040\uff9f\041\uff9f\042\uff9f\043\uff9f\045\uff9f" +
    "\047\uff9f\053\uff9f\001\002\000\026\017\124\025\123\030" +
    "\125\032\112\036\111\044\115\050\127\051\122\052\116" +
    "\053\113\001\002\000\066\004\uff8a\006\uff8a\007\uff8a\010" +
    "\uff8a\011\uff8a\013\uff8a\014\uff8a\015\uff8a\016\uff8a\020\uff8a" +
    "\022\uff8a\023\uff8a\026\uff8a\027\uff8a\030\uff8a\031\uff8a\033" +
    "\uff8a\034\uff8a\037\uff8a\040\uff8a\041\uff8a\042\uff8a\043\uff8a" +
    "\045\uff8a\047\uff8a\053\uff8a\001\002\000\036\004\141\010" +
    "\162\014\142\016\144\020\153\022\147\026\156\027\154" +
    "\030\140\031\150\033\151\037\155\040\145\043\152\001" +
    "\002\000\066\004\uffa0\006\uffa0\007\uffa0\010\uffa0\011\uffa0" +
    "\013\uffa0\014\uffa0\015\uffa0\016\uffa0\020\uffa0\022\uffa0\023" +
    "\uffa0\026\uffa0\027\uffa0\030\uffa0\031\uffa0\033\uffa0\034\uffa0" +
    "\037\uffa0\040\uffa0\041\uffa0\042\uffa0\043\uffa0\045\uffa0\047" +
    "\uffa0\053\uffa0\001\002\000\004\036\136\001\002\000\066" +
    "\004\uff9c\006\uff9c\007\uff9c\010\uff9c\011\uff9c\013\uff9c\014" +
    "\uff9c\015\uff9c\016\uff9c\020\uff9c\022\uff9c\023\uff9c\026\uff9c" +
    "\027\uff9c\030\uff9c\031\uff9c\033\uff9c\034\uff9c\037\uff9c\040" +
    "\uff9c\041\uff9c\042\uff9c\043\uff9c\045\uff9c\047\uff9c\053\uff9c" +
    "\001\002\000\026\017\uff95\025\uff95\030\uff95\032\uff95\036" +
    "\uff95\044\uff95\050\uff95\051\uff95\052\uff95\053\uff95\001\002" +
    "\000\066\004\uff88\006\uff88\007\uff88\010\uff88\011\uff88\013" +
    "\uff88\014\uff88\015\uff88\016\uff88\020\uff88\022\uff88\023\uff88" +
    "\026\uff88\027\uff88\030\uff88\031\uff88\033\uff88\034\uff88\037" +
    "\uff88\040\uff88\041\uff88\042\uff88\043\uff88\045\uff88\047\uff88" +
    "\053\uff88\001\002\000\066\004\uffa1\006\uffa1\007\uffa1\010" +
    "\uffa1\011\uffa1\013\uffa1\014\uffa1\015\uffa1\016\uffa1\020\uffa1" +
    "\022\uffa1\023\uffa1\026\uffa1\027\uffa1\030\uffa1\031\uffa1\033" +
    "\uffa1\034\uffa1\037\uffa1\040\uffa1\041\uffa1\042\uffa1\043\uffa1" +
    "\045\uffa1\047\uffa1\053\uffa1\001\002\000\026\017\uff92\025" +
    "\uff92\030\135\032\uff92\036\uff92\044\uff92\050\uff92\051\uff92" +
    "\052\uff92\053\uff92\001\002\000\026\017\uff93\025\uff93\030" +
    "\uff93\032\134\036\uff93\044\uff93\050\uff93\051\uff93\052\uff93" +
    "\053\uff93\001\002\000\066\004\uff90\006\uff90\007\uff90\010" +
    "\uff90\011\uff90\013\uff90\014\uff90\015\uff90\016\uff90\020\uff90" +
    "\022\uff90\023\uff90\026\uff90\027\uff90\030\uff90\031\uff90\033" +
    "\uff90\034\uff90\037\uff90\040\uff90\041\uff90\042\uff90\043\uff90" +
    "\045\uff90\047\uff90\053\uff90\001\002\000\066\004\uff9e\006" +
    "\uff9e\007\uff9e\010\uff9e\011\uff9e\013\uff9e\014\uff9e\015\uff9e" +
    "\016\uff9e\020\uff9e\022\uff9e\023\uff9e\026\uff9e\027\uff9e\030" +
    "\uff9e\031\uff9e\033\uff9e\034\uff9e\037\uff9e\040\uff9e\041\uff9e" +
    "\042\uff9e\043\uff9e\045\uff9e\047\uff9e\053\uff9e\001\002\000" +
    "\026\017\uff96\025\uff96\030\uff96\032\uff96\036\uff96\044\uff96" +
    "\050\uff96\051\uff96\052\uff96\053\uff96\001\002\000\026\017" +
    "\uff94\025\uff94\030\uff94\032\uff94\036\uff94\044\uff94\050\uff94" +
    "\051\uff94\052\uff94\053\uff94\001\002\000\026\017\124\025" +
    "\123\030\125\032\112\036\111\044\115\050\127\051\122" +
    "\052\116\053\113\001\002\000\036\004\141\011\157\014" +
    "\142\016\144\020\153\022\147\026\156\027\154\030\140" +
    "\031\150\033\151\037\155\040\145\043\152\001\002\000" +
    "\026\017\uff85\025\uff85\030\uff85\032\uff85\036\uff85\044\uff85" +
    "\050\uff85\051\uff85\052\uff85\053\uff85\001\002\000\026\017" +
    "\uffad\025\uffad\030\uffad\032\uffad\036\uffad\044\uffad\050\uffad" +
    "\051\uffad\052\uffad\053\uffad\001\002\000\026\017\uff81\025" +
    "\uff81\030\uff81\032\uff81\036\uff81\044\uff81\050\uff81\051\uff81" +
    "\052\uff81\053\uff81\001\002\000\026\017\124\025\123\030" +
    "\125\032\112\036\111\044\115\050\127\051\122\052\116" +
    "\053\113\001\002\000\026\017\uffb3\025\uffb3\030\uffb3\032" +
    "\uffb3\036\uffb3\044\uffb3\050\uffb3\051\uffb3\052\uffb3\053\uffb3" +
    "\001\002\000\026\017\uff83\025\uff83\030\uff83\032\uff83\036" +
    "\uff83\044\uff83\050\uff83\051\uff83\052\uff83\053\uff83\001\002" +
    "\000\026\017\124\025\123\030\125\032\112\036\111\044" +
    "\115\050\127\051\122\052\116\053\113\001\002\000\026" +
    "\017\uffb1\025\uffb1\030\uffb1\032\uffb1\036\uffb1\044\uffb1\050" +
    "\uffb1\051\uffb1\052\uffb1\053\uffb1\001\002\000\026\017\uff84" +
    "\025\uff84\030\uff84\032\uff84\036\uff84\044\uff84\050\uff84\051" +
    "\uff84\052\uff84\053\uff84\001\002\000\026\017\uffae\025\uffae" +
    "\030\uffae\032\uffae\036\uffae\044\uffae\050\uffae\051\uffae\052" +
    "\uffae\053\uffae\001\002\000\026\017\uff82\025\uff82\030\uff82" +
    "\032\uff82\036\uff82\044\uff82\050\uff82\051\uff82\052\uff82\053" +
    "\uff82\001\002\000\026\017\uffb2\025\uffb2\030\uffb2\032\uffb2" +
    "\036\uffb2\044\uffb2\050\uffb2\051\uffb2\052\uffb2\053\uffb2\001" +
    "\002\000\026\017\uffaf\025\uffaf\030\uffaf\032\uffaf\036\uffaf" +
    "\044\uffaf\050\uffaf\051\uffaf\052\uffaf\053\uffaf\001\002\000" +
    "\026\017\uffac\025\uffac\030\uffac\032\uffac\036\uffac\044\uffac" +
    "\050\uffac\051\uffac\052\uffac\053\uffac\001\002\000\026\017" +
    "\uffb0\025\uffb0\030\uffb0\032\uffb0\036\uffb0\044\uffb0\050\uffb0" +
    "\051\uffb0\052\uffb0\053\uffb0\001\002\000\066\004\uff8c\006" +
    "\uff8c\007\uff8c\010\uff8c\011\uff8c\013\uff8c\014\uff8c\015\uff8c" +
    "\016\uff8c\020\uff8c\022\uff8c\023\uff8c\026\uff8c\027\uff8c\030" +
    "\uff8c\031\uff8c\033\uff8c\034\uff8c\037\uff8c\040\uff8c\041\uff8c" +
    "\042\uff8c\043\uff8c\045\uff8c\047\uff8c\053\uff8c\001\002\000" +
    "\066\004\141\006\uff8d\007\uff8d\010\uff8d\011\uff8d\013\uff8d" +
    "\014\142\015\uff8d\016\144\020\153\022\147\023\uff8d\026" +
    "\156\027\154\030\140\031\150\033\151\034\uff8d\037\155" +
    "\040\145\041\uff8d\042\uff8d\043\152\045\uff8d\047\uff8d\053" +
    "\uff8d\001\002\000\066\004\141\006\uff8e\007\uff8e\010\uff8e" +
    "\011\uff8e\013\uff8e\014\142\015\uff8e\016\144\020\153\022" +
    "\147\023\uff8e\026\156\027\154\030\140\031\150\033\151" +
    "\034\uff8e\037\155\040\145\041\uff8e\042\uff8e\043\152\045" +
    "\uff8e\047\uff8e\053\uff8e\001\002\000\072\004\uff7c\006\uff7c" +
    "\007\uff7c\010\uff7c\011\uff7c\013\uff7c\014\uff7c\015\uff7c\016" +
    "\uff7c\020\uff7c\021\uff7c\022\uff7c\023\uff7c\026\uff7c\027\uff7c" +
    "\030\uff7c\031\uff7c\033\uff7c\034\uff7c\035\uff7c\037\uff7c\040" +
    "\uff7c\041\uff7c\042\uff7c\043\uff7c\045\uff7c\047\uff7c\053\uff7c" +
    "\001\002\000\066\004\141\006\uff91\007\uff91\010\uff91\011" +
    "\uff91\013\uff91\014\142\015\uff91\016\144\020\153\022\147" +
    "\023\uff91\026\156\027\154\030\140\031\150\033\151\034" +
    "\uff91\037\155\040\145\041\uff91\042\uff91\043\152\045\uff91" +
    "\047\uff91\053\uff91\001\002\000\072\004\uff7d\006\uff7d\007" +
    "\uff7d\010\uff7d\011\uff7d\013\uff7d\014\uff7d\015\uff7d\016\uff7d" +
    "\020\uff7d\021\uff7d\022\uff7d\023\uff7d\026\uff7d\027\uff7d\030" +
    "\uff7d\031\uff7d\033\uff7d\034\uff7d\035\110\037\uff7d\040\uff7d" +
    "\041\uff7d\042\uff7d\043\uff7d\045\uff7d\047\uff7d\053\uff7d\001" +
    "\002\000\044\004\141\007\uff9b\011\uff9b\013\uff9b\014\142" +
    "\016\144\020\153\022\147\026\156\027\154\030\140\031" +
    "\150\033\151\037\155\040\145\042\uff9b\043\152\001\002" +
    "\000\006\011\170\013\167\001\002\000\026\017\124\025" +
    "\123\030\125\032\112\036\111\044\115\050\127\051\122" +
    "\052\116\053\113\001\002\000\066\004\uff8f\006\uff8f\007" +
    "\uff8f\010\uff8f\011\uff8f\013\uff8f\014\uff8f\015\uff8f\016\uff8f" +
    "\020\uff8f\022\uff8f\023\uff8f\026\uff8f\027\uff8f\030\uff8f\031" +
    "\uff8f\033\uff8f\034\uff8f\037\uff8f\040\uff8f\041\uff8f\042\uff8f" +
    "\043\uff8f\045\uff8f\047\uff8f\053\uff8f\001\002\000\044\004" +
    "\141\007\uff9a\011\uff9a\013\uff9a\014\142\016\144\020\153" +
    "\022\147\026\156\027\154\030\140\031\150\033\151\037" +
    "\155\040\145\042\uff9a\043\152\001\002\000\006\013\uffce" +
    "\021\uffce\001\002\000\034\006\uffea\007\uffea\013\uffea\015" +
    "\uffea\021\uffea\023\uffea\034\uffea\035\175\041\uffea\042\uffea" +
    "\045\uffea\047\uffea\053\uffea\001\002\000\032\006\uffe9\007" +
    "\uffe9\013\uffe9\015\uffe9\021\uffe9\023\uffe9\034\uffe9\041\uffe9" +
    "\042\uffe9\045\uffe9\047\uffe9\053\uffe9\001\002\000\030\010" +
    "\205\017\124\025\123\030\125\032\112\036\111\044\115" +
    "\050\127\051\122\052\116\053\113\001\002\000\034\006" +
    "\uffe3\007\uffe3\013\uffe3\015\uffe3\021\uffe3\023\uffe3\034\uffe3" +
    "\035\203\041\uffe3\042\uffe3\045\uffe3\047\uffe3\053\uffe3\001" +
    "\002\000\034\006\uffe4\007\uffe4\013\uffe4\015\uffe4\021\uffe4" +
    "\023\uffe4\034\uffe4\035\201\041\uffe4\042\uffe4\045\uffe4\047" +
    "\uffe4\053\uffe4\001\002\000\032\006\uffe6\007\uffe6\013\uffe6" +
    "\015\uffe6\021\uffe6\023\uffe6\034\uffe6\041\uffe6\042\uffe6\045" +
    "\uffe6\047\uffe6\053\uffe6\001\002\000\030\010\205\017\124" +
    "\025\123\030\125\032\112\036\111\044\115\050\127\051" +
    "\122\052\116\053\113\001\002\000\034\006\uffe5\007\uffe5" +
    "\013\uffe5\015\uffe5\021\uffe5\023\uffe5\034\uffe5\035\203\041" +
    "\uffe5\042\uffe5\045\uffe5\047\uffe5\053\uffe5\001\002\000\004" +
    "\010\204\001\002\000\034\006\uffe1\007\uffe1\013\uffe1\015" +
    "\uffe1\021\uffe1\023\uffe1\034\uffe1\035\uffe1\041\uffe1\042\uffe1" +
    "\045\uffe1\047\uffe1\053\uffe1\001\002\000\034\006\uffe2\007" +
    "\uffe2\013\uffe2\015\uffe2\021\uffe2\023\uffe2\034\uffe2\035\uffe2" +
    "\041\uffe2\042\uffe2\045\uffe2\047\uffe2\053\uffe2\001\002\000" +
    "\036\004\141\010\207\014\142\016\144\020\153\022\147" +
    "\026\156\027\154\030\140\031\150\033\151\037\155\040" +
    "\145\043\152\001\002\000\034\006\uffe0\007\uffe0\013\uffe0" +
    "\015\uffe0\021\uffe0\023\uffe0\034\uffe0\035\uffe0\041\uffe0\042" +
    "\uffe0\045\uffe0\047\uffe0\053\uffe0\001\002\000\036\004\141" +
    "\010\211\014\142\016\144\020\153\022\147\026\156\027" +
    "\154\030\140\031\150\033\151\037\155\040\145\043\152" +
    "\001\002\000\034\006\uffdf\007\uffdf\013\uffdf\015\uffdf\021" +
    "\uffdf\023\uffdf\034\uffdf\035\uffdf\041\uffdf\042\uffdf\045\uffdf" +
    "\047\uffdf\053\uffdf\001\002\000\006\011\213\013\167\001" +
    "\002\000\070\004\uff86\006\uff86\007\uff86\010\uff86\011\uff86" +
    "\013\uff86\014\uff86\015\uff86\016\uff86\020\uff86\022\uff86\023" +
    "\uff86\026\uff86\027\uff86\030\uff86\031\uff86\033\uff86\034\uff86" +
    "\035\uff86\037\uff86\040\uff86\041\uff86\042\uff86\043\uff86\045" +
    "\uff86\047\uff86\053\uff86\001\002\000\036\004\141\010\215" +
    "\014\142\016\144\020\153\022\147\026\156\027\154\030" +
    "\140\031\150\033\151\037\155\040\145\043\152\001\002" +
    "\000\072\004\uff7b\006\uff7b\007\uff7b\010\uff7b\011\uff7b\013" +
    "\uff7b\014\uff7b\015\uff7b\016\uff7b\020\uff7b\021\uff7b\022\uff7b" +
    "\023\uff7b\026\uff7b\027\uff7b\030\uff7b\031\uff7b\033\uff7b\034" +
    "\uff7b\035\uff7b\037\uff7b\040\uff7b\041\uff7b\042\uff7b\043\uff7b" +
    "\045\uff7b\047\uff7b\053\uff7b\001\002\000\022\006\uffdb\007" +
    "\uffdb\023\uffdb\034\uffdb\041\uffdb\045\uffdb\047\uffdb\053\uffdb" +
    "\001\002\000\016\006\231\023\061\034\223\045\051\047" +
    "\054\053\057\001\002\000\026\017\124\025\123\030\125" +
    "\032\112\036\111\044\115\050\127\051\122\052\116\053" +
    "\113\001\002\000\036\004\141\011\222\014\142\016\144" +
    "\020\153\022\147\026\156\027\154\030\140\031\150\033" +
    "\151\037\155\040\145\043\152\001\002\000\016\006\uff8b" +
    "\023\uff8b\034\uff8b\045\uff8b\047\uff8b\053\uff8b\001\002\000" +
    "\022\006\uffdd\007\uffdd\023\uffdd\034\uffdd\041\uffdd\045\uffdd" +
    "\047\uffdd\053\uffdd\001\002\000\024\006\uffbe\007\uffbe\015" +
    "\uffb5\023\uffbe\034\uffbe\041\uffbe\045\uffbe\047\uffbe\053\uffbe" +
    "\001\002\000\024\006\uffc9\007\uffc9\015\uffb4\023\uffc9\034" +
    "\uffc9\041\uffc9\045\uffc9\047\uffc9\053\uffc9\001\002\000\026" +
    "\006\uff7f\007\uff7f\015\uff7f\023\uff7f\034\uff7f\041\uff7f\042" +
    "\015\045\uff7f\047\uff7f\053\uff7f\001\002\000\022\006\uffbd" +
    "\007\uffbd\023\uffbd\034\uffbd\041\uffbd\045\uffbd\047\uffbd\053" +
    "\uffbd\001\002\000\026\006\uff7f\007\uff7f\015\uff7f\023\uff7f" +
    "\034\uff7f\041\uff7f\042\015\045\uff7f\047\uff7f\053\uff7f\001" +
    "\002\000\026\006\uff7f\007\uff7f\015\uff7f\023\uff7f\034\uff7f" +
    "\041\uff7f\042\015\045\uff7f\047\uff7f\053\uff7f\001\002\000" +
    "\026\006\uff7f\007\uff7f\015\uff7f\023\uff7f\034\uff7f\041\uff7f" +
    "\042\015\045\uff7f\047\uff7f\053\uff7f\001\002\000\022\006" +
    "\uffc7\007\uffc7\023\uffc7\034\uffc7\041\uffc7\045\uffc7\047\uffc7" +
    "\053\uffc7\001\002\000\004\015\235\001\002\000\016\006" +
    "\246\023\240\034\241\045\051\047\054\053\057\001\002" +
    "\000\026\006\uff7f\007\uff7f\015\uff7f\023\uff7f\034\uff7f\041" +
    "\uff7f\042\015\045\uff7f\047\uff7f\053\uff7f\001\002\000\024" +
    "\006\uffb4\007\uffb4\015\uffb4\023\uffb4\034\uffb4\041\uffb4\045" +
    "\uffb4\047\uffb4\053\uffb4\001\002\000\004\036\220\001\002" +
    "\000\022\006\uffdd\007\uffdd\023\uffdd\034\uffdd\041\uffdd\045" +
    "\uffdd\047\uffdd\053\uffdd\001\002\000\026\006\uff7f\007\uff7f" +
    "\015\uff7f\023\uff7f\034\uff7f\041\uff7f\042\015\045\uff7f\047" +
    "\uff7f\053\uff7f\001\002\000\024\006\uffb5\007\uffb5\015\uffb5" +
    "\023\uffb5\034\uffb5\041\uffb5\045\uffb5\047\uffb5\053\uffb5\001" +
    "\002\000\024\006\uffc6\007\uffc6\015\uffc6\023\uffc6\034\uffc6" +
    "\041\uffc6\045\uffc6\047\uffc6\053\uffc6\001\002\000\026\006" +
    "\uff7f\007\uff7f\015\uff7f\023\uff7f\034\uff7f\041\uff7f\042\015" +
    "\045\uff7f\047\uff7f\053\uff7f\001\002\000\026\006\uff7f\007" +
    "\uff7f\015\uff7f\023\uff7f\034\uff7f\041\uff7f\042\015\045\uff7f" +
    "\047\uff7f\053\uff7f\001\002\000\024\006\uffb9\007\uffb9\015" +
    "\uffb9\023\uffb9\034\uffb9\041\uffb9\045\uffb9\047\uffb9\053\uffb9" +
    "\001\002\000\024\006\uffb8\007\uffb8\015\uffb8\023\uffb8\034" +
    "\uffb8\041\uffb8\045\uffb8\047\uffb8\053\uffb8\001\002\000\024" +
    "\006\uffb7\007\uffb7\015\uffb7\023\uffb7\034\uffb7\041\uffb7\045" +
    "\uffb7\047\uffb7\053\uffb7\001\002\000\022\006\253\007\254" +
    "\023\061\034\052\041\056\045\051\047\054\053\057\001" +
    "\002\000\006\007\uff7f\042\015\001\002\000\024\006\uffba" +
    "\007\uffba\015\uffba\023\uffba\034\uffba\041\uffba\045\uffba\047" +
    "\uffba\053\uffba\001\002\000\004\007\256\001\002\000\024" +
    "\006\uffbb\007\uffbb\015\uffbb\023\uffbb\034\uffbb\041\uffbb\045" +
    "\uffbb\047\uffbb\053\uffbb\001\002\000\004\007\260\001\002" +
    "\000\024\006\uffbc\007\uffbc\015\uffbc\023\uffbc\034\uffbc\041" +
    "\uffbc\045\uffbc\047\uffbc\053\uffbc\001\002\000\016\006\246" +
    "\023\240\034\241\045\051\047\054\053\057\001\002\000" +
    "\024\006\uffb6\007\uffb6\015\uffb6\023\uffb6\034\uffb6\041\uffb6" +
    "\045\uffb6\047\uffb6\053\uffb6\001\002\000\024\006\uffc1\007" +
    "\uffc1\015\uffb8\023\uffc1\034\uffc1\041\uffc1\045\uffc1\047\uffc1" +
    "\053\uffc1\001\002\000\024\006\uffc2\007\uffc2\015\uffb9\023" +
    "\uffc2\034\uffc2\041\uffc2\045\uffc2\047\uffc2\053\uffc2\001\002" +
    "\000\024\006\uffbf\007\uffbf\015\uffb6\023\uffbf\034\uffbf\041" +
    "\uffbf\045\uffbf\047\uffbf\053\uffbf\001\002\000\024\006\uffc0" +
    "\007\uffc0\015\uffb7\023\uffc0\034\uffc0\041\uffc0\045\uffc0\047" +
    "\uffc0\053\uffc0\001\002\000\022\006\270\007\271\023\061" +
    "\034\052\041\056\045\051\047\054\053\057\001\002\000" +
    "\006\007\uff7f\042\015\001\002\000\024\006\uffc3\007\uffc3" +
    "\015\uffba\023\uffc3\034\uffc3\041\uffc3\045\uffc3\047\uffc3\053" +
    "\uffc3\001\002\000\004\007\273\001\002\000\024\006\uffc4" +
    "\007\uffc4\015\uffbb\023\uffc4\034\uffc4\041\uffc4\045\uffc4\047" +
    "\uffc4\053\uffc4\001\002\000\004\007\275\001\002\000\024" +
    "\006\uffc5\007\uffc5\015\uffbc\023\uffc5\034\uffc5\041\uffc5\045" +
    "\uffc5\047\uffc5\053\uffc5\001\002\000\032\011\uff99\013\uff99" +
    "\017\124\025\123\030\125\032\112\036\111\044\115\050" +
    "\127\051\122\052\116\053\113\001\002\000\006\005\032" +
    "\024\034\001\002\000\032\006\uffd5\007\uffd5\013\uffd1\015" +
    "\uffd5\021\uffd1\023\uffd5\034\uffd5\041\uffd5\042\uffd5\045\uffd5" +
    "\047\uffd5\053\uffd5\001\002\000\006\011\302\013\167\001" +
    "\002\000\030\006\uff98\007\uff98\015\uff98\023\uff98\034\uff98" +
    "\035\uff86\041\uff98\042\uff98\045\uff98\047\uff98\053\uff98\001" +
    "\002\000\010\007\uff7f\013\167\042\015\001\002\000\004" +
    "\007\uffd4\001\002\000\016\006\315\023\240\034\311\045" +
    "\051\047\054\053\057\001\002\000\026\006\uff7f\007\uff7f" +
    "\015\uff7f\023\uff7f\034\uff7f\041\uff7f\042\015\045\uff7f\047" +
    "\uff7f\053\uff7f\001\002\000\024\006\uffa4\007\uffa4\015\uffa4" +
    "\023\uffa4\034\uffa4\041\uffa4\045\uffa4\047\uffa4\053\uffa4\001" +
    "\002\000\024\006\uffab\007\uffab\015\uffab\023\uffab\034\uffab" +
    "\041\uffab\045\uffab\047\uffab\053\uffab\001\002\000\022\006" +
    "\uffdd\007\uffdd\023\uffdd\034\uffdd\041\uffdd\045\uffdd\047\uffdd" +
    "\053\uffdd\001\002\000\026\006\uff7f\007\uff7f\015\uff7f\023" +
    "\uff7f\034\uff7f\041\uff7f\042\015\045\uff7f\047\uff7f\053\uff7f" +
    "\001\002\000\024\006\uffa3\007\uffa3\015\uffa3\023\uffa3\034" +
    "\uffa3\041\uffa3\045\uffa3\047\uffa3\053\uffa3\001\002\000\026" +
    "\006\uff7f\007\uff7f\015\uff7f\023\uff7f\034\uff7f\041\uff7f\042" +
    "\015\045\uff7f\047\uff7f\053\uff7f\001\002\000\026\006\uff7f" +
    "\007\uff7f\015\uff7f\023\uff7f\034\uff7f\041\uff7f\042\015\045" +
    "\uff7f\047\uff7f\053\uff7f\001\002\000\024\006\uffa7\007\uffa7" +
    "\015\uffa7\023\uffa7\034\uffa7\041\uffa7\045\uffa7\047\uffa7\053" +
    "\uffa7\001\002\000\024\006\uffa6\007\uffa6\015\uffa6\023\uffa6" +
    "\034\uffa6\041\uffa6\045\uffa6\047\uffa6\053\uffa6\001\002\000" +
    "\024\006\uffa5\007\uffa5\015\uffa5\023\uffa5\034\uffa5\041\uffa5" +
    "\045\uffa5\047\uffa5\053\uffa5\001\002\000\022\006\322\007" +
    "\323\023\061\034\052\041\056\045\051\047\054\053\057" +
    "\001\002\000\006\007\uff7f\042\015\001\002\000\024\006" +
    "\uffa8\007\uffa8\015\uffa8\023\uffa8\034\uffa8\041\uffa8\045\uffa8" +
    "\047\uffa8\053\uffa8\001\002\000\004\007\325\001\002\000" +
    "\024\006\uffa9\007\uffa9\015\uffa9\023\uffa9\034\uffa9\041\uffa9" +
    "\045\uffa9\047\uffa9\053\uffa9\001\002\000\004\007\327\001" +
    "\002\000\024\006\uffaa\007\uffaa\015\uffaa\023\uffaa\034\uffaa" +
    "\041\uffaa\045\uffaa\047\uffaa\053\uffaa\001\002\000\024\006" +
    "\uffa2\007\uffa2\015\uffa2\023\uffa2\034\uffa2\041\uffa2\045\uffa2" +
    "\047\uffa2\053\uffa2\001\002\000\016\007\336\023\061\034" +
    "\052\045\051\047\054\053\057\001\002\000\034\007\uff99" +
    "\013\uff99\017\124\025\123\030\125\032\112\036\111\042" +
    "\uff99\044\115\050\127\051\122\052\116\053\113\001\002" +
    "\000\010\007\uff7f\013\167\042\015\001\002\000\004\007" +
    "\335\001\002\000\022\006\uffd6\007\uffd6\023\uffd6\034\uffd6" +
    "\041\uffd6\045\uffd6\047\uffd6\053\uffd6\001\002\000\022\006" +
    "\uffd7\007\uffd7\023\uffd7\034\uffd7\041\uffd7\045\uffd7\047\uffd7" +
    "\053\uffd7\001\002\000\060\004\141\006\uffd3\007\uffd3\014" +
    "\142\015\uffd3\016\144\020\153\022\147\023\uffd3\026\156" +
    "\027\154\030\140\031\150\033\151\034\uffd3\037\155\040" +
    "\145\041\uffd3\042\uffd3\043\152\045\uffd3\047\uffd3\053\uffd3" +
    "\001\002\000\006\005\032\024\034\001\002\000\020\007" +
    "\uffdd\023\uffdd\034\uffdd\041\uffdd\045\uffdd\047\uffdd\053\uffdd" +
    "\001\002\000\020\007\343\023\061\034\052\041\056\045" +
    "\051\047\054\053\057\001\002\000\006\002\ufff7\053\ufff7" +
    "\001\002\000\004\007\345\001\002\000\006\002\ufff8\053" +
    "\ufff8\001\002\000\006\013\uffef\034\uffef\001\002\000\006" +
    "\013\ufff0\034\ufff0\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\346\000\010\002\003\003\005\004\004\001\001\000" +
    "\002\001\001\000\010\005\011\006\006\007\007\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\051\020\001\001\000\006\006\016\007\017\001\001" +
    "\000\002\001\001\000\004\042\015\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\011\044\001\001\000\004\010\023\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\013\032\056\030\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\057\034" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\013\032\056\042\001\001\000\002\001\001\000" +
    "\006\013\032\056\346\001\001\000\002\001\001\000\004" +
    "\020\046\001\001\000\034\021\052\022\070\023\072\024" +
    "\066\025\063\026\047\027\065\032\054\036\062\044\064" +
    "\047\061\050\067\060\057\001\001\000\024\034\125\035" +
    "\132\040\336\043\131\044\117\053\130\054\127\055\116" +
    "\060\113\001\001\000\002\001\001\000\004\020\330\001" +
    "\001\000\002\001\001\000\004\052\304\001\001\000\002" +
    "\001\001\000\026\034\125\035\132\037\302\040\164\043" +
    "\131\044\117\053\130\054\127\055\116\060\113\001\001" +
    "\000\004\045\106\001\001\000\004\045\163\001\001\000" +
    "\004\052\216\001\001\000\002\001\001\000\004\042\215" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\042\075\001\001\000\002\001\001\000\004" +
    "\042\074\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\044\100\060\057\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\045\106\001\001\000\024" +
    "\034\125\035\132\040\213\043\131\044\117\053\130\054" +
    "\127\055\116\060\113\001\001\000\026\034\125\035\132" +
    "\037\211\040\164\043\131\044\117\053\130\054\127\055" +
    "\116\060\113\001\001\000\010\012\171\013\172\014\173" +
    "\001\001\000\002\001\001\000\024\034\125\035\132\040" +
    "\120\043\131\044\117\053\130\054\127\055\116\060\113" +
    "\001\001\000\026\034\125\035\132\037\165\040\164\043" +
    "\131\044\117\053\130\054\127\055\116\060\113\001\001" +
    "\000\002\001\001\000\004\045\106\001\001\000\004\045" +
    "\163\001\001\000\002\001\001\000\002\001\001\000\024" +
    "\034\125\035\132\040\162\043\131\044\117\053\130\054" +
    "\127\055\116\060\113\001\001\000\002\001\001\000\006" +
    "\031\145\041\142\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\024\034\125\035\132\040\136\043\131\044" +
    "\117\053\130\054\127\055\116\060\113\001\001\000\006" +
    "\031\145\041\142\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\024\034\125\035\132\040\160" +
    "\043\131\044\117\053\130\054\127\055\116\060\113\001" +
    "\001\000\002\001\001\000\002\001\001\000\024\034\125" +
    "\035\132\040\157\043\131\044\117\053\130\054\127\055" +
    "\116\060\113\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\031\145\041\142\001\001\000\006\031" +
    "\145\041\142\001\001\000\002\001\001\000\006\031\145" +
    "\041\142\001\001\000\002\001\001\000\006\031\145\041" +
    "\142\001\001\000\002\001\001\000\024\034\125\035\132" +
    "\040\170\043\131\044\117\053\130\054\127\055\116\060" +
    "\113\001\001\000\002\001\001\000\006\031\145\041\142" +
    "\001\001\000\002\001\001\000\010\015\177\016\176\017" +
    "\175\001\001\000\002\001\001\000\024\034\125\035\132" +
    "\040\207\043\131\044\117\053\130\054\127\055\116\060" +
    "\113\001\001\000\002\001\001\000\004\017\201\001\001" +
    "\000\002\001\001\000\024\034\125\035\132\040\205\043" +
    "\131\044\117\053\130\054\127\055\116\060\113\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\031\145\041\142\001\001\000\002" +
    "\001\001\000\006\031\145\041\142\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\031\145" +
    "\041\142\001\001\000\002\001\001\000\002\001\001\000" +
    "\034\022\231\024\227\025\063\026\047\027\226\030\232" +
    "\032\223\036\225\044\064\046\233\047\224\050\067\060" +
    "\057\001\001\000\024\034\125\035\132\040\220\043\131" +
    "\044\117\053\130\054\127\055\116\060\113\001\001\000" +
    "\006\031\145\041\142\001\001\000\002\001\001\000\004" +
    "\020\266\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\042\265\001\001\000\002\001\001\000\004\042\264" +
    "\001\001\000\004\042\263\001\001\000\004\042\262\001" +
    "\001\000\002\001\001\000\002\001\001\000\026\022\244" +
    "\024\235\025\063\026\047\032\242\036\241\044\064\046" +
    "\243\047\236\060\057\001\001\000\004\042\261\001\001" +
    "\000\002\001\001\000\004\052\260\001\001\000\004\020" +
    "\251\001\001\000\004\042\250\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\042\247\001\001\000\004\042" +
    "\246\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\034\021\052\022\070\023\254\024\066\025" +
    "\063\026\047\027\065\032\054\036\062\044\064\047\061" +
    "\050\067\060\057\001\001\000\004\042\256\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\026\022\244\024\235\025" +
    "\063\026\047\032\242\036\241\044\064\046\233\047\236" +
    "\060\057\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\034" +
    "\021\052\022\070\023\271\024\066\025\063\026\047\027" +
    "\065\032\054\036\062\044\064\047\061\050\067\060\057" +
    "\001\001\000\004\042\273\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\026\034\125\035\132\037\300\040\164\043" +
    "\131\044\117\053\130\054\127\055\116\060\113\001\001" +
    "\000\010\012\277\013\172\014\173\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\042\303" +
    "\001\001\000\002\001\001\000\026\022\313\024\305\025" +
    "\063\026\047\032\312\033\307\036\311\044\064\047\306" +
    "\060\057\001\001\000\004\042\327\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\020\320\001\001\000\004" +
    "\042\317\001\001\000\002\001\001\000\004\042\316\001" +
    "\001\000\004\042\315\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\034\021\052\022\070\023" +
    "\323\024\066\025\063\026\047\027\065\032\054\036\062" +
    "\044\064\047\061\050\067\060\057\001\001\000\004\042" +
    "\325\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\032\021\052\022\070\024\066\025\063\026\047" +
    "\027\065\032\054\036\062\044\064\047\061\050\067\060" +
    "\057\001\001\000\026\034\125\035\132\037\332\040\164" +
    "\043\131\044\117\053\130\054\127\055\116\060\113\001" +
    "\001\000\004\042\333\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\031\145\041\142\001" +
    "\001\000\006\013\032\056\345\001\001\000\004\020\341" +
    "\001\001\000\034\021\052\022\070\023\343\024\066\025" +
    "\063\026\047\027\065\032\054\036\062\044\064\047\061" +
    "\050\067\060\057\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return ((JFlexLexer)getScanner()).next(); 
    }

 
 
  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Syntax error ");

    if (info instanceof XiSymbol){
      XiSymbol x = (XiSymbol)info;
      m.append( "on line " + x.position().lineStart() );
      m.append( " at token " + x.value() + "\n");
      try{
        BufferedReader br = new BufferedReader(new FileReader(x.position().unit()));
        String line = "could not read";
        for(int i=0;i<x.position().lineStart();i++){
          line = br.readLine();
        }
        m.append("  ");
        for(int i=0;i<x.position().columnStart()-1;i++){
          m.append(" ");
      }
      m.append("v\n");
      m.append("  " + line.replace('\t',' ') + "\n");
      }catch (FileNotFoundException f){
        System.err.println("Unable to find file"+x.position().unit());
      }catch (IOException i){
        System.err.println("Unable to read file"+x.position().unit());
      }
    }
    //m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    //throw new RuntimeException("Fatal Syntax Error");
  }



}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {
  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // bracket_index ::= OPEN_BRACKET expression CLOSE_BRACKET 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 ArrayList<ExpressionNode> ar = new ArrayList<ExpressionNode>(); 
																				ar.add(e);
																				RESULT = ar; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bracket_index",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // bracket_index ::= bracket_index OPEN_BRACKET expression CLOSE_BRACKET 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ArrayList<ExpressionNode> b = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 b.add(e); RESULT = b; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bracket_index",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // array_lookup ::= function_call bracket_index 
            {
              ArrayLookUpNode RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		FunctionCallNode func = (FunctionCallNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<ExpressionNode> i = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ArrayLookUpNode(func,i,func.position(),i.get(0).position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_lookup",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // array_lookup ::= IDENTIFIER bracket_index 
            {
              ArrayLookUpNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<ExpressionNode> i = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ArrayLookUpNode(id.value(),i,id.position(),i.get(0).position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_lookup",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // semicolon_opt ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("semicolon_opt",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // semicolon_opt ::= SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("semicolon_opt",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // math_function ::= DIVIDE 
            {
              MathFunctionNode RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol m = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new MathFunctionNode(Sym.DIVIDE,m.position(),m.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("math_function",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // math_function ::= TIMES 
            {
              MathFunctionNode RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol m = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new MathFunctionNode(Sym.TIMES,m.position(),m.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("math_function",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // math_function ::= PLUS 
            {
              MathFunctionNode RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol m = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new MathFunctionNode(Sym.PLUS,m.position(),m.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("math_function",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // math_function ::= MODULO 
            {
              MathFunctionNode RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol m = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new MathFunctionNode(Sym.MODULO,m.position(),m.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("math_function",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // math_function ::= MINUS 
            {
              MathFunctionNode RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol m = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new MathFunctionNode(Sym.MINUS,m.position(),m.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("math_function",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // function_call ::= IDENTIFIER OPEN_PAREN expression_list CLOSE_PAREN 
            {
              FunctionCallNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ArrayList<ExpressionNode> args = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new FunctionCallNode(id.value(),args,id.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_call",46, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // fil ::= function_call 
            {
              SyntaxNode RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		FunctionCallNode p = (FunctionCallNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = p; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("fil",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // fil ::= literal 
            {
              SyntaxNode RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SyntaxNode p = (SyntaxNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = p; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("fil",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // fil ::= IDENTIFIER 
            {
              SyntaxNode RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol p = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new VarNode(p.value(),p.position(),p.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("fil",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // fil ::= array_lookup 
            {
              SyntaxNode RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayLookUpNode p = (ArrayLookUpNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = p; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("fil",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // expression_paren ::= OPEN_PAREN expression CLOSE_PAREN 
            {
              ExpressionNode RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = e; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression_paren",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // expression ::= LENGTH OPEN_PAREN expression CLOSE_PAREN 
            {
              ExpressionNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int argleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int argright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ExpressionNode arg = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new ExpressionNode("length",arg, id.position(),arg.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // expression ::= expression comparison_operator expression 
            {
              ExpressionNode RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ExpressionNode e1 = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ComparisonOperatorNode m = (ComparisonOperatorNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpressionNode e2 = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new ExpressionNode(e1, m, e2,e1.position(),e2.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // expression ::= expression math_function expression 
            {
              ExpressionNode RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ExpressionNode e1 = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		MathFunctionNode m = (MathFunctionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpressionNode e2 = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new ExpressionNode(e1, m, e2,e1.position(),e2.position());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // expression ::= OPEN_PAREN expression_list CLOSE_PAREN 
            {
              ExpressionNode RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol f = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ArrayList<ExpressionNode> e = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol l = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new ExpressionNode(e,f.position(),l.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // expression ::= fil 
            {
              ExpressionNode RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SyntaxNode f = (SyntaxNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new ExpressionNode(f,f.position(),f.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // expression ::= unary expression 
            {
              ExpressionNode RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SyntaxNode n = (SyntaxNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpressionNode f = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new ExpressionNode(n,f,n.position(),f.position());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // unary ::= minus_opt 
            {
              SyntaxNode RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		MinusNode n = (MinusNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT= n; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unary",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // unary ::= not_opt 
            {
              SyntaxNode RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NotNode n = (NotNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT= n; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unary",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // minus_opt ::= minus_opt MINUS 
            {
              MinusNode RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		MinusNode m = (MinusNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = m.addMinus(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("minus_opt",42, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // minus_opt ::= MINUS 
            {
              MinusNode RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol n = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new MinusNode(n.position(),n.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("minus_opt",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // not_opt ::= not_opt NOT 
            {
              NotNode RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NotNode n = (NotNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = n.addNot(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("not_opt",41, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // not_opt ::= NOT 
            {
              NotNode RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol n = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new NotNode(n.position(),n.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("not_opt",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // procedure_call ::= IDENTIFIER OPEN_PAREN expression_list CLOSE_PAREN 
            {
              ProcedureCallNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ArrayList<ExpressionNode> args = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ProcedureCallNode(id.value(),args,id.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_call",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // expression_list ::= 
            {
              ArrayList<ExpressionNode> RESULT =null;
		 RESULT = new ArrayList<ExpressionNode>(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression_list",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // expression_list ::= expression_list COMMA expression 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int elleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int elright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ArrayList<ExpressionNode> el = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 el.add(e); RESULT = el; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression_list",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // expression_list ::= expression 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 ArrayList<ExpressionNode> ar = new ArrayList<ExpressionNode>(); ar.add(e); RESULT = ar; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression_list",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // boolean_literal ::= FALSE 
            {
              XiSymbol RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol f = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new XiSymbol(Sym.FALSE,"false",f.position().lineStart(),f.position().columnStart(),f.position().columnEnd(),f.position().unit()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("boolean_literal",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // boolean_literal ::= TRUE 
            {
              XiSymbol RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol t = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new XiSymbol(Sym.TRUE,"true",t.position().lineStart(),t.position().columnStart(),t.position().columnEnd(),t.position().unit()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("boolean_literal",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // literal ::= boolean_literal 
            {
              SyntaxNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new BoolLiteralNode(id.value(),id.position(),id.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // literal ::= STRING_LITERAL 
            {
              SyntaxNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new StringLiteralNode(id.value(),id.position(),id.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // literal ::= CHAR_LITERAL 
            {
              SyntaxNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new CharLiteralNode(id.value(),id.position(),id.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // literal ::= INTEGER_LITERAL 
            {
              SyntaxNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new IntegerLiteralNode(Integer.parseInt(id.value()),id.position(),id.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // loop_body ::= assignments semicolon_opt 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AssignmentNode s = (AssignmentNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_body",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // loop_body ::= loops 
            {
              StatementNode RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		WhileNode c = (WhileNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = c; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_body",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // loop_body ::= matched 
            {
              StatementNode RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ConditionNode c = (ConditionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = c; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_body",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // loop_body ::= procedure_call semicolon_opt 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ProcedureCallNode s = (ProcedureCallNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_body",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // loop_body ::= declarations semicolon_opt 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		DeclarationNode s = (DeclarationNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_body",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // loop_body ::= BREAK semicolon_opt 
            {
              StatementNode RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		XiSymbol b = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new BreakNode(b.position(),b.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_body",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // loop_body ::= OPEN_BRACE statements CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 if(s.position()==null){
		                                                             s.setPosition(o.position());
									   } RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_body",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // loop_body ::= OPEN_BRACE statements return_opt CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ReturnNode r = (ReturnNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 s.addReturn(r,r.position(),r.position()); RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_body",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // loop_body ::= OPEN_BRACE statements BREAK semicolon_opt CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol b = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s.addStatement(new BreakNode(b.position(),b.position()),o.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_body",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // loops ::= WHILE expression_paren loop_body 
            {
              WhileNode RESULT =null;
		int wleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int wright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol w = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ExpressionNode args = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		StatementNode b = (StatementNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new WhileNode(args,b,w.position(),b.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loops",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // comparison_operator ::= OR 
            {
              ComparisonOperatorNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ComparisonOperatorNode(Sym.OR,o.position(),o.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("comparison_operator",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // comparison_operator ::= AND 
            {
              ComparisonOperatorNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ComparisonOperatorNode(Sym.AND,o.position(),o.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("comparison_operator",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // comparison_operator ::= NOT_EQUAL 
            {
              ComparisonOperatorNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ComparisonOperatorNode(Sym.NOT_EQUAL,o.position(),o.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("comparison_operator",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // comparison_operator ::= LT 
            {
              ComparisonOperatorNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ComparisonOperatorNode(Sym.LT,o.position(),o.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("comparison_operator",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // comparison_operator ::= LEQ 
            {
              ComparisonOperatorNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ComparisonOperatorNode(Sym.LEQ,o.position(),o.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("comparison_operator",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // comparison_operator ::= GT 
            {
              ComparisonOperatorNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ComparisonOperatorNode(Sym.GT,o.position(),o.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("comparison_operator",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // comparison_operator ::= GEQ 
            {
              ComparisonOperatorNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ComparisonOperatorNode(Sym.GEQ,o.position(),o.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("comparison_operator",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // comparison_operator ::= EQUAL 
            {
              ComparisonOperatorNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new ComparisonOperatorNode(Sym.EQUAL,o.position(),o.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("comparison_operator",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // conditional_run_matched ::= matched 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ConditionNode s = (ConditionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run_matched",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // conditional_run_matched ::= loops 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		WhileNode s = (WhileNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run_matched",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // conditional_run_matched ::= assignments semicolon_opt 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AssignmentNode s = (AssignmentNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run_matched",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // conditional_run_matched ::= procedure_call semicolon_opt 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ProcedureCallNode s = (ProcedureCallNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run_matched",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // conditional_run_matched ::= declarations semicolon_opt 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		DeclarationNode s = (DeclarationNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run_matched",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // conditional_run_matched ::= BREAK semicolon_opt 
            {
              StatementNode RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		XiSymbol b = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new BreakNode(b.position(),b.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run_matched",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // conditional_run_matched ::= OPEN_BRACE statements CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 if(s.position()==null){
		                                                                             s.setPosition(o.position());
									                   } RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run_matched",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // conditional_run_matched ::= OPEN_BRACE statements return_opt CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ReturnNode r = (ReturnNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 s.addReturn(r,r.position(),r.position()); RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run_matched",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // conditional_run_matched ::= OPEN_BRACE statements BREAK semicolon_opt CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol b = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s.addStatement(new BreakNode(b.position(),b.position()),o.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run_matched",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // conditional_run ::= conditionals 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ConditionNode s = (ConditionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // conditional_run ::= loops 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		WhileNode s = (WhileNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // conditional_run ::= assignments semicolon_opt 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AssignmentNode s = (AssignmentNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // conditional_run ::= procedure_call semicolon_opt 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ProcedureCallNode s = (ProcedureCallNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // conditional_run ::= declarations semicolon_opt 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		DeclarationNode s = (DeclarationNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // conditional_run ::= BREAK semicolon_opt 
            {
              StatementNode RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		XiSymbol b = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new BreakNode(b.position(),b.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // conditional_run ::= OPEN_BRACE statements CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 if(s.position()==null){
		                                                               s.setPosition(o.position());
									     } RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // conditional_run ::= OPEN_BRACE statements return_opt CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ReturnNode r = (ReturnNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 s.addReturn(r,r.position(),r.position()); RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // conditional_run ::= OPEN_BRACE statements BREAK semicolon_opt CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol b = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s.addStatement(new BreakNode(b.position(),b.position()),o.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditional_run",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // matched ::= IF expression_paren conditional_run_matched ELSE conditional_run_matched 
            {
              ConditionNode RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		StatementNode c = (StatementNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int clleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int clright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		StatementNode cl = (StatementNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new ConditionNode(e,c,cl,e.position(),cl.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // unmatched ::= IF expression_paren conditional_run 
            {
              ConditionNode RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		StatementNode c = (StatementNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new ConditionNode(e,c,e.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unmatched",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // conditionals ::= unmatched 
            {
              ConditionNode RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ConditionNode m = (ConditionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = m; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditionals",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // conditionals ::= matched 
            {
              ConditionNode RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ConditionNode m = (ConditionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = m; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("conditionals",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // assign_lhs ::= assign_lhs COMMA array_lookup 
            {
              LHSListNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		LHSListNode a = (LHSListNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayLookUpNode b = (ArrayLookUpNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = a.addLHS(b,a.position(),b.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_lhs",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // assign_lhs ::= array_lookup 
            {
              LHSListNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayLookUpNode a = (ArrayLookUpNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new LHSListNode(a,a.position(),a.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_lhs",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // assign_lhs ::= assign_lhs COMMA IDENTIFIER 
            {
              LHSListNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		LHSListNode a = (LHSListNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = a.addLHS(id.value(),a.position(),id.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_lhs",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // assign_lhs ::= assign_lhs COMMA UNDERSCORE 
            {
              LHSListNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		LHSListNode a = (LHSListNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int uleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int uright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol u = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = a.addLHS(a.position(),u.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_lhs",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // assign_lhs ::= assign_lhs COMMA IDENTIFIER COLON type 
            {
              LHSListNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		LHSListNode a = (LHSListNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = a.addLHS(id.value(),t,a.position(),id.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_lhs",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // assign_lhs ::= IDENTIFIER 
            {
              LHSListNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new LHSListNode(id.value(),id.position(),id.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_lhs",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // assign_lhs ::= UNDERSCORE 
            {
              LHSListNode RESULT =null;
		int uleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int uright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol u = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new LHSListNode(u.position(),u.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_lhs",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // assign_lhs ::= IDENTIFIER COLON type 
            {
              LHSListNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new LHSListNode(id.value(),t,id.position(),id.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_lhs",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // left_hand_side ::= assign_lhs GETS 
            {
              LHSListNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LHSListNode a = (LHSListNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = a; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("left_hand_side",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // assignments ::= left_hand_side expression 
            {
              AssignmentNode RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LHSListNode a = (LHSListNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new AssignmentNode(a,e,a.position(),e.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assignments",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // return_opt ::= RETURN expression_list semicolon_opt 
            {
              ReturnNode RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol r = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ArrayList<ExpressionNode> e = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 if(e.size()==0){
                                                                             RESULT = new ReturnNode(e,r.position(),r.position());
									   }else{
									     RESULT = new ReturnNode(e,e.get(0).position(),e.get(e.size()-1).position());
									   } 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_opt",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // declarations ::= IDENTIFIER COLON type 
            {
              DeclarationNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new DeclarationNode(id.value(),t,id.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // statement ::= OPEN_BRACE RETURN expression_list semicolon_opt CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		XiSymbol r = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ArrayList<ExpressionNode> e = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 if (e == null) {
			                                                                      RESULT = new ReturnNode(new ArrayList<ExpressionNode>(),r.position(),r.position());
																		     } else{
																			      RESULT = new ReturnNode(e,r.position(),r.position());
																			 }	  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // statement ::= OPEN_BRACE statements CLOSE_BRACE 
            {
              StatementNode RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		StatementsNode c = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int clleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int clright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol cl = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 StatementsNode sn = new StatementsNode(); 
									   if(c.position()==null){
									     sn.addStatement(c,o.position(),cl.position()); RESULT = sn; 
									   }else{
									     sn.addStatement(c,o.position(),c.position()); RESULT = sn; 
									   }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // statement ::= loops 
            {
              StatementNode RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		WhileNode c = (WhileNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = c; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // statement ::= conditionals 
            {
              StatementNode RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ConditionNode c = (ConditionNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = c; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // statement ::= assignments semicolon_opt 
            {
              StatementNode RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AssignmentNode c = (AssignmentNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = c; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // statement ::= procedure_call semicolon_opt 
            {
              StatementNode RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ProcedureCallNode c = (ProcedureCallNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = c; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // statement ::= declarations semicolon_opt 
            {
              StatementNode RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		DeclarationNode c = (DeclarationNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = c; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // statements ::= 
            {
              StatementsNode RESULT =null;
		 RESULT = new StatementsNode(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statements",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // statements ::= statements statement 
            {
              StatementsNode RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		StatementNode c = (StatementNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s.addStatement(c,s.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statements",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // non_empty_brackets ::= OPEN_BRACKET expression CLOSE_BRACKET 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 ArrayList<ExpressionNode>  ar = new ArrayList<ExpressionNode>(); 
							   ar.add(e);
							   RESULT = ar; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_empty_brackets",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // non_empty_brackets ::= non_empty_brackets OPEN_BRACKET expression CLOSE_BRACKET 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ArrayList<ExpressionNode> b = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ExpressionNode e = (ExpressionNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 b.add(e); RESULT = b; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_empty_brackets",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // empty_brackets ::= empty_brackets OPEN_BRACKET CLOSE_BRACKET 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int ebleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ebright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ArrayList<ExpressionNode> eb = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 eb.add(new IntegerLiteralNode(0,o.position(),c.position())); RESULT = eb; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("empty_brackets",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // empty_brackets ::= OPEN_BRACKET CLOSE_BRACKET 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		XiSymbol o = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 ArrayList<ExpressionNode> ar = new ArrayList<ExpressionNode>();
                                                     ar.add(new IntegerLiteralNode(0,o.position(),c.position()));
													 RESULT = ar; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("empty_brackets",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // brackets ::= empty_brackets 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<ExpressionNode> b = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = b; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("brackets",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // brackets ::= non_empty_brackets 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int nbleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nbright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<ExpressionNode> nb = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = nb; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("brackets",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // brackets ::= non_empty_brackets empty_brackets 
            {
              ArrayList<ExpressionNode> RESULT =null;
		int nbleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nbright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ArrayList<ExpressionNode> nb = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<ExpressionNode> b = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 nb.addAll(b); RESULT = nb; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("brackets",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // array ::= primitive_type brackets 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<ExpressionNode> b = (ArrayList<ExpressionNode>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 switch (t.type) { 
						case INT: RESULT = new Type(Type.typeEnum.INT_ARRAY,b); break;
						case BOOL: RESULT = new Type(Type.typeEnum.BOOL_ARRAY,b); break; 
						} 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // primitive_type ::= BOOL 
            {
              Type RESULT =null;
		 RESULT = new Type(Type.typeEnum.BOOL); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primitive_type",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // primitive_type ::= INT 
            {
              Type RESULT =null;
		 RESULT = new Type(Type.typeEnum.INT); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primitive_type",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // type ::= array 
            {
              Type RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type a = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = a; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // type ::= primitive_type 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // parameter_brackets ::= parameter_brackets OPEN_BRACKET CLOSE_BRACKET 
            {
              Integer RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Integer b = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = b + 1; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_brackets",45, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // parameter_brackets ::= OPEN_BRACKET CLOSE_BRACKET 
            {
              Integer RESULT =null;
		 RESULT = 1; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_brackets",45, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // parameter_type ::= primitive_type parameter_brackets 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Integer b = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 switch (t.type) { 
						case INT: RESULT = new Type(Type.typeEnum.INT_ARRAY,b); break;
						case BOOL: RESULT = new Type(Type.typeEnum.BOOL_ARRAY,b); break; 
						} 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_type",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // parameter_type ::= primitive_type 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_type",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // return_type ::= return_type COMMA parameter_type 
            {
              ArrayList<Type> RESULT =null;
		int rtleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rtright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ArrayList<Type> rt = (ArrayList<Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 rt.add(t); RESULT = rt; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // return_type ::= COLON parameter_type 
            {
              ArrayList<Type> RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 ArrayList<Type> ar = new ArrayList<Type>(); ar.add(t); RESULT = ar; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_type",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // parameters ::= 
            {
              LinkedHashMap<String,Type> RESULT =null;
		 RESULT = new LinkedHashMap<String,Type>(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameters",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // parameters ::= parameters COMMA IDENTIFIER COLON parameter_type 
            {
              LinkedHashMap<String,Type> RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		LinkedHashMap<String,Type> p = (LinkedHashMap<String,Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 p.put(id.value(),t); RESULT = p; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameters",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // parameters ::= IDENTIFIER COLON parameter_type 
            {
              LinkedHashMap<String,Type> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 LinkedHashMap<String,Type> mappi = new LinkedHashMap<String,Type>(); mappi.put(id.value(),t); RESULT = mappi; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameters",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // parameters_paren ::= OPEN_PAREN parameters CLOSE_PAREN 
            {
              LinkedHashMap<String,Type> RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LinkedHashMap<String,Type> p = (LinkedHashMap<String,Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = p; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameters_paren",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // procedure ::= IDENTIFIER parameters_paren OPEN_BRACE statements return_opt CLOSE_BRACE 
            {
              FunctionDecNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		LinkedHashMap<String,Type> p = (LinkedHashMap<String,Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ReturnNode r = (ReturnNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new FunctionDecNode(id.value(),p,new ArrayList<Type>(),s,r,id.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // procedure ::= IDENTIFIER parameters_paren OPEN_BRACE statements CLOSE_BRACE 
            {
              FunctionDecNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		LinkedHashMap<String,Type> p = (LinkedHashMap<String,Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new FunctionDecNode(id.value(),p,new ArrayList<Type>(),s,null,id.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // function ::= IDENTIFIER parameters_paren return_type OPEN_BRACE statements CLOSE_BRACE 
            {
              FunctionDecNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		LinkedHashMap<String,Type> p = (LinkedHashMap<String,Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ArrayList<Type> r = (ArrayList<Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new FunctionDecNode(id.value(),p,r,s,null,id.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // function ::= IDENTIFIER parameters_paren return_type OPEN_BRACE statements return_opt CLOSE_BRACE 
            {
              FunctionDecNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		LinkedHashMap<String,Type> p = (LinkedHashMap<String,Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		ArrayList<Type> r = (ArrayList<Type>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		StatementsNode s = (StatementsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int roleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int roright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ReturnNode ro = (ReturnNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		XiSymbol c = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new FunctionDecNode(id.value(),p,r,s,ro,id.position(),c.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // functions ::= procedure 
            {
              FunctionsNode RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		FunctionDecNode f = (FunctionDecNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new FunctionsNode(f,f.position(),f.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("functions",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // functions ::= function 
            {
              FunctionsNode RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		FunctionDecNode f = (FunctionDecNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new FunctionsNode(f,f.position(),f.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("functions",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // functions ::= functions procedure 
            {
              FunctionsNode RESULT =null;
		int fsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		FunctionsNode fs = (FunctionsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		FunctionDecNode f = (FunctionDecNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = fs.addFunction(f); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("functions",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // functions ::= functions function 
            {
              FunctionsNode RESULT =null;
		int fsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		FunctionsNode fs = (FunctionsNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		FunctionDecNode f = (FunctionDecNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = fs.addFunction(f); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("functions",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // use_opt ::= 
            {
              UseNode RESULT =null;
		 RESULT = new UseNode(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("use_opt",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // use_opt ::= use_opt USE IDENTIFIER semicolon_opt 
            {
              UseNode RESULT =null;
		int uleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int uright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		UseNode u = (UseNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int useTleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int useTright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		XiSymbol useT = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		XiSymbol id = (XiSymbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = u.addUse(id.value(),u.position(),useT.position(),id.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("use_opt",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // compilation_unit ::= use_opt functions 
            {
              CompUnitNode RESULT =null;
		int uleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int uright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		UseNode u = (UseNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		FunctionsNode fs = (FunctionsNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new CompUnitNode(u,fs,u.position(),fs.position()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("compilation_unit",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // goal ::= compilation_unit 
            {
              CompUnitNode RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CompUnitNode c = (CompUnitNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = c; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("goal",0, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= goal EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		CompUnitNode start_val = (CompUnitNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

